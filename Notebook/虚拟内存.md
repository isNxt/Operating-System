# 虚拟内存

## 为什么可行？

1、程序可以分块

2、部分加载到内存（要运行部分）

3、运行时，不在内存中再加载

4、部分加载到内存中的块可以是不连续的

虚拟内存=》扩充内存=》增加多道程序设计道数（从挂起，虚拟内存，部分加载，分配部分内存给用户程序）

## 如何在需要的时候加载不在内存中的块（类似于缺页处理的过程）？

1、发出不在内存的中断

2、进程=》阻塞

3、OS加载程序块到内存（对程序员透明，系统负责）

3.5 用户内存满的问题（置换算法）

4、加载完成，进程=》就绪

5、重新进行调度

## 系统抖动:

如果系统大部分时间都用于交换（IO操作）而没有执行用的指令，使得用户进程处于基本停滞状态

硬盘灯一直闪，界面卡住

如何避免系统抖动？

原因：马上要使用的块被换出，使用时又被换入，并且这种现象频率很高。=》块的使用预测不准=》提高预测的准确度=》用历史的数据=》原理：局部性原理（空间和时间）

## 页式管理：

1、进程分页

2、内存分帧

3、页帧等大小

地址映射：页表，逻辑地址=》物理地址

逻辑地址=页号+页内偏移量

物理地址=帧号+帧内偏移量

页号=》帧号对应关系

页表项：帧号信息

该页是否被加载到内存：p（1位）

该页被置换的时候是否需要回写=》内存中的帧和硬盘（虚拟内存）中的进程页是否一致？

=》M(1位)，修改位

## 地址映射：

指令或数据的访问由原来的一次变成两次

1、访问页表

2、访问指令或数据

提升速度

- 页表：TLB（特殊cache）

- 针对数据：cache

### 一、只有页表

1、访问指令/数据（逻辑地址）

2、页号

3、找到页表项

4、p==1，取帧号，=》形成物理地址

5、p==0，缺页中断=》进程=》阻塞

6、OS缺页处理

7、完成，进程=》就绪

8、重新获得cpu使用权

9、逻辑地址

10、页号

11、页表项

12、取出帧号（p==1），形成物理地址

### 二、页表+TLB

TLB：硬件特性，级联查找设备（在一次访问时间内能判断所查找的数据是否在TLB内，在则返回该数据位置）

地址映射路径2=》3

1、TLB中存在所对应的页表项

2、页表+p==1，更新TLB

3、页表+p==0，缺页中断（缺页处理），页错误（在缺页处理完成时，需要更新页表=》更新存在位、帧号），然后执行2

### 三、页表+TLB+Cache

五条：
1、TLB+Cache

2、TLB+内存

3、页表（p==1）+Cache

4、页表（p==1）+内存

5、页表（p==0）+缺页+4

#### 页表要占用内存空间

1、进程很多，每一个进程一个页表

2、进程很大，页表很大=》页表占用太多内存

1、二级页表，把页表放在虚拟内存中

二级页表：

逻辑地址=页号1+页号2+页内偏移量

物理地址=帧号+帧内偏移量

一个进程对应两个页表（进程和页表的页表）

地址映射，分成两次

一次：页表对应的首地址

二次：帧号

2、限制页表的大小（倒排页表）

倒排页表：

帧号与页号的对应关系

页号，每个进程都是从0开始编号，重复对应关系的时候，需要知道对应的是哪个仅存页号？

页表中：页号，进程ID

Hash函数做页号到帧号的映射，M:1关系=》多个页号映射到同一个帧号=》重复，重叠=》链指针（把所有对应到同一个帧号的链接起来）=》线性散列，溢出链表

 页表的大小和哪些因素有关？

页表的大小：

1、进程大小

2、进程数量（内存中总页表大小）

3、帧号大小（帧号的位数）

4、页大小

5、控制位

倒排页表大小：

1、内存大小

2、帧号大小

3、页大小（页的位数）

4、控制位

