并发性:互斥与同步
并发性无处不在,应用程序,管理程序,OS>>并发性引发的问题无可避免>>解决
概念:
临界区:代码段,互斥
死锁:两个或两个以上的一组进程,互相等待,无法继续执行{就绪}
活锁:为了其他进程能继续执行而做改变(无用功)
互斥:一次最多只有一个进程执行
饥饿:就绪进程,无限期忽视,无法获得CPU控制权,无法继续执行
竞争条件:共享变量,失败者决定最后的值

OS关注的问题:
1.进程:跟踪
2.资源:分配与释放
3.保护:进程与资源
进程间的关系:
1.互相不知道:竞争,互斥,死锁,饥饿
2.知道对方(不知道id):共享,互斥,死锁,饥饿
3.知道对方(ID):直接通讯,共享,合作

并发性问题>>本质>>并发>>不并发(串行)>>规则:一次只允许一个进程进入>>临界区
并发>>物理并行(多CPU)+逻辑并行(单CPU)>>统一解决方案(禁用中断例外)

临界区解决方案:
1.禁用中断
2.compare_and_swap
3.exchange
4.信号量
5.管程
6.消息

判断临界区方案的有效性:(不能死锁,不能饥饿,细粒度尽可能小)
1.临界区中没有执行的进程,一个想进入临界区的进程可以立即进入
2.临界区中没有执行的进程,其他进程可以无法进入(等待)
3.临界区中的进程要在有限时间内离开(执行完毕)>>条件的重置
4.临界区中执行的进程离开后,等待的进程能进入
临界区:
EnterCritical(Pa)
ExitCritical(Ra)
1.禁用中断
禁用中断
临界区中执行的进程离开后启动中断
代价大,细粒度是系统级的,对多CPU无效
2.compare_and_sqap
三个参数,一个返回
001
101
while(compare_and_swap(bolt,0,1)==1);
临界区
bolt=0;
忙等待,饥饿,死锁(低优先级的进程在临界区中被强占)
exchange(v1,v2)
keyi进程的局部变量
while(keyi!=1)exchange(keyi,bolt);
临界区;
exchange(leyi,bolt);//bolt=0;
忙等待,饥饿,死锁
4.信号量
struct semaphore{
int count;//信号量的值,一般初始化为>=0
Queue q;//信号量下的排队队列,该队列下的所有进程处于阻塞状态并等待该信号
}
原语:
senSignal(s);V(s);
semWait(s);P(s);
先加检,再判断.
semWait(s)
count--;
if count<0 排队(1.进程进队列2.改进程状态)
semSignal(s)
count++;
if count>=0 离开排队(1.进程进就绪队列2.改进程状态)

